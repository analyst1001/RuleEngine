// Generated by CoffeeScript 1.6.2
/*

  Describes a FactHash object and an Agenda object for handling agendas

  sortAgenda(a, b) --> 1 or -1
    a --> most probably a tree node
    b --> most probably a tree node
  returns 1 or -1 to indicate the ordering of nodes

  FactHash object
    memory --> a list of facts
    memoryValues --> a list of lists containing values related to fact a corresponding index

    clear() --> empties memory and memoryValues

    get(k) --> List
      k --> fact related to which values are to be get
    returns a list of values related to fact

    __compact() --> removes the facts from memory which do not have any values

    remove(v) --> Nothing
      v --> Value to remove
    removes the value from all the facts it is present in

    insert(insert) --> Nothing
      insert --> values to be inserted
    insert the value in all facts the value is to be inserted in

    Agenda Object
      agendaGroups --> dictionary for storing AVL tree corresponding to an agenda
      agendaGroupStack --> a list for keeping track of currently focussed agenda
      rules --> a dictionary ???
      flow --> ???
      addAgendaGroup(groupName) --> Nothing
        groupName --> Name of the agenda group to add
      adds the agenda group to the agendaGroups dictionary

      getAgendaGroup(groupName) --> AVLTree object
        groupName --> Name of the agenda group whose AVL tree is to be obtained
      returns the AVL tree corresponding to a group name

      setFocus(agendaGroup) --> Agenda object
        agendaGroup --> the agenda group to be set on focus
      returns a modified Agenda object with agendaGroup parameter focused

      getFocused() -> returns the agendaGroup which is currently focused

      getFocusedAgenda() --> returns the AVL tree corresponding to the currently focused agenda group

      register(node) --> Nothing
        node --> the node to be registered in Agenda object
      updates the Agenda object to get the node registered

      isEmpty() --> Boolean
      returns True if there are no agenda groups with anything in their corresponding AVL trees

      fireNext() --> Boolean
      fires the next activation rule

      pop() --> ???
      removes the last node from the currently focused agenda

      removeByFact(node, fact) --> ???

      retract(node, cb) --> Nothing
      removes data from factTable, AVLtree corresponding to the agenda groupn and tree corresponding to the rule corresponding to the node depending on the callback function

      insert(node, insert) --> Nothing
        node --> a tree node
        insert --> value to be inserted
      inserts the insert parameter in the tree, agendaGroup and factTable corresponding to the rule corresponding to the node

      dispose() --> clears all the data structures in the Agenda object
*/


(function() {
  "use strict";
  var AVLTree, DEFAULT_AGENDA_GROUP, EventEmitter, FactHash, REVERSE_ORDER, When, declare, extd, indexOf, sortAgenda;

  extd = require('./extended');

  When = extd.when;

  indexOf = extd.indexOf;

  declare = extd.declare;

  AVLTree = extd.AVLTree;

  EventEmitter = require("events").EventEmitter;

  sortAgenda = function(a, b) {
    var aLength, aMatchRecency, bLength, bMatchRecency, i, p1, p2, ret;

    if (a === b) {
      return 0;
    }
    p1 = a.rule.priority;
    p2 = b.rule.priority;
    if (p1 !== p2) {
      ret = p1 - p2;
    } else if (a.counter !== b.counter) {
      ret = a.counter - b.counter;
    }
    if (!ret) {
      i = 0;
      aMatchRecency = a.match.recency;
      bMatchRecency = b.match.recency;
      aLength = aMatchRecency.length - 1;
      bLength = bMatchRecency.length - 1;
      while (aMatchRecency[i] === bMatchRecency[i] && i < aLength && i < bLength) {
        i++;
      }
      ret = aMatchRecency[i] - bMatchRecency[i];
      if (!ret) {
        ret = aLength - bLength;
      }
    }
    if (!ret) {
      ret = a.recency - b.recency;
    }
    return (ret > 0 ? 1 : -1);
  };

  FactHash = declare({
    instance: {
      constructor: function() {
        this.memory = [];
        return this.memoryValues = [];
      },
      clear: function() {
        return this.memory.length = this.memoryValues.length = 0;
      },
      get: function(k) {
        return this.memoryValues[indexOf(this.memory, k)];
      },
      __compact: function() {
        var i, oldM, oldMemoryValue, oldMv, _i, _len, _results;

        oldM = this.memory.slice(0);
        oldMv = this.memoryValues.slice(0);
        this.memory = [];
        this.memoryValues = [];
        _results = [];
        for (i = _i = 0, _len = oldMv.length; _i < _len; i = ++_i) {
          oldMemoryValue = oldMv[i];
          if (oldMemoryValue.length !== 0) {
            _results.push(this.memoryValues[this.memory.push(oldM[i]) - 1] = oldMemoryValue);
          }
        }
        return _results;
      },
      remove: function(v) {
        var arr, fact, facts, i, index, _i, _len;

        facts = v.match.facts;
        for (_i = 0, _len = facts.length; _i < _len; _i++) {
          fact = facts[_i];
          i = indexOf(this.memory, fact);
          arr = this.memoryValues[i];
          index = indexOf(arr, v);
          arr.splice(index, 1);
        }
        return this.__compact();
      },
      insert: function(insert) {
        var arr, fact, facts, i, _i, _len, _results;

        facts = insert.match.facts;
        _results = [];
        for (_i = 0, _len = facts.length; _i < _len; _i++) {
          fact = facts[_i];
          i = indexOf(this.memory, fact);
          arr = this.memoryValues[i];
          if (!arr) {
            arr = this.memoryValues[this.memory.push(fact) - 1] = [];
          }
          _results.push(arr.push(insert));
        }
        return _results;
      }
    }
  });

  REVERSE_ORDER = AVLTree.REVERSE_ORDER;

  DEFAULT_AGENDA_GROUP = "main";

  module.exports = declare(EventEmitter, {
    instance: {
      constructor: function(flow) {
        this.agendaGroups = {};
        this.agendaGroupStack = [DEFAULT_AGENDA_GROUP];
        this.rules = {};
        this.flow = flow;
        return this.setFocus(DEFAULT_AGENDA_GROUP).addAgendaGroup(DEFAULT_AGENDA_GROUP);
      },
      addAgendaGroup: function(groupName) {
        if (!extd.has(this.agendaGroups, groupName)) {
          return this.agendaGroups[groupName] = new AVLTree({
            compare: sortAgenda
          });
        }
      },
      getAgendaGroup: function(groupName) {
        return this.agendaGroups[groupName || DEFAULT_AGENDA_GROUP];
      },
      setFocus: function(agendaGroup) {
        if (agendaGroup !== this.getFocused()) {
          this.agendaGroupStack.push(agendaGroup);
          this.emit("focused", agendaGroup);
        }
        return this;
      },
      getFocused: function() {
        return this.agendaGroupStack[this.agendaGroupStack.length - 1];
      },
      getFocusedAgenda: function() {
        return this.agendaGroups[this.getFocused];
      },
      register: function(node) {
        var agendaGroup;

        agendaGroup = node.rule.agendaGroup;
        this.rules[node.name] = {
          tree: new AVLTree({
            compare: sortAgenda
          }),
          factTable: new FactHash()
        };
        if (agendaGroup) {
          return this.addAgendaGroup(agendaGroup);
        }
      },
      isEmpty: function() {
        var changed;

        changed = false;
        while (this.getFocusedAgenda().isEmpty() && this.getFocused !== DEFAULT_AGENDA_GROUP) {
          this.agendaGroupStack.pop();
          changed = true;
        }
        if (changed) {
          emit("focused", this.getFocused);
        }
        return this.getFocusedAgenda.isEmpty();
      },
      fireNext: function() {
        var activation;

        while (this.getFocusedAgenda().isEmpty() && this.getFocused !== DEFAULT_AGENDA_GROUP) {
          this.agendaGroupStack.pop();
        }
        if (!this.getFocusedAgenda().isEmpty()) {
          activation = this.pop();
          this.emit("fire", activation.rule.name, activation.match.FactHash);
          return When(activation.rule.fire(this.flow, activation.match)).then(function() {
            return true;
          });
        }
        return extd.resolve(false);
      },
      pop: function() {
        var root, rule, tree, v;

        tree = this.getFocusedAgenda;
        root = tree.__root;
        while (root.right) {
          root = root.right;
        }
        v = root.data;
        tree.remove(v);
        rule = this.rules[v.name];
        rule.tree.remove(v);
        rule.factTable.remove(v);
        return v;
      },
      removeByFact: function(node, fact) {
        var factTable, ma, r, remove, rule, tree, _i, _len;

        rule = this.rules[node.name];
        tree = rule.tree;
        factTable = rule.factTable;
        ma = this.getAgendaGroup(node.rule.agendaGroup);
        remove = factTable.get(fact) || [];
        for (_i = 0, _len = remove.length; _i < _len; _i++) {
          r = remove[_i];
          factTable.remove(r);
          tree.remove(r);
          ma.remove(r);
        }
        return remove.length = 0;
      },
      retract: function(node, cb) {
        var factTable, ma, rule, tree;

        rule = this.rules[node.name];
        tree = rule.tree;
        factTable = rule.factTable;
        ma = this.getAgendaGroup(node.rule.agendaGroup);
        return tree.traverse(tree.__root, REVERSE_ORDER, function(v) {
          if (cb(v)) {
            ma.remove(v);
            return tree.remove(v);
          }
        });
      },
      insert: function(node, insert) {
        var agendaGroup, nodeRule, rule;

        rule = this.rules[node.name];
        nodeRule = node.rule;
        agendaGroup = nodeRule.agendaGroup;
        rule.tree.insert(insert);
        this.getAgendaGroup(agendaGroup).insert(insert);
        if (agendaGroup && nodeRule.autoFocus) {
          this.setFocus(agendaGroup);
        }
        return rule.factTable.insert(insert);
      },
      dispose: function() {
        var i, rules, _i, _len;

        for (i in this.agendaGroups) {
          this.agendaGroups[i].clear;
        }
        rules = this.rules;
        for (_i = 0, _len = rules.length; _i < _len; _i++) {
          i = rules[_i];
          rules[i].tree.clear();
          rules[i].factTable.clear();
        }
        return this.rules = {};
      }
    }
  });

}).call(this);
