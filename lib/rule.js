// Generated by CoffeeScript 1.6.2
/*
  Defines function for creating a rule from given condition patterns. Describes Rule object

  getParamTypeSwitcher(param) --> Different types
    param --> string describing parameter type
  returns an instance of the type described by the parameter

  getParamType(param) --> Different types
    param --> a string, function or an empty array
  returns an instance of the type of param

  parsePattern(pattern) --> List
    pattern --> list describing a condition in rule
  returns a list of pattern objects for each condition in pattern parameter

  Rule --> defines a Rule object
    constructor : set name, options, conditions and callback function of the rule
    fire : calls the callback function

  createRule(name, options, conditions, cb) --> Rule Object
    name --> name of the rule
    options --> ???
    conditions --> ???
    cb ---> callback function to fire
  returns a list of Rule objects for each condition
*/


(function() {
  "use strict";
  var CompositePattern, NotPattern, ObjectPattern, Promise, Rule, createRule, declare, extd, getParamType, getParamTypeSwitcher, isArray, parsePattern, parser, pattern;

  extd = require('./extended');

  isArray = extd.isArray;

  Promise = extd.Promise;

  declare = extd.declare;

  parser = require('./parser');

  pattern = require('./pattern.coffee');

  ObjectPattern = pattern.ObjectPattern;

  NotPattern = pattern.NotPattern;

  CompositePattern = pattern.CompositePattern;

  getParamTypeSwitcher = function(param) {
    switch (param) {
      case "string":
        return String;
      case "date":
        return Date;
      case "array":
        return Array;
      case "boolean":
        return Boolean;
      case "regexp":
        return RegExp;
      case "number":
        return Number;
      case "object":
        return Object;
      case "hash":
        return Object;
      default:
        throw new TypeError("Invalid parameter type " + param);
    }
  };

  getParamType = extd.switcher().isString(function(param) {
    return getParamTypeSwitcher(param.toLowerCase);
  }).isFunction(function(func) {
    return func;
  }).deepEqual([], function() {
    return Array;
  }).def(function(param) {
    throw new Error("Invalid parameter type " + param);
  }).switcher();

  parsePattern = function(pattern) {
    switch (pattern) {
      case extd(pattern).containsAt("or", 0):
        pattern.shift();
        return extd(pattern).map(function(cond) {
          cond.scope = pattern.scope;
          return parsePattern(cond);
        }).flatten().value();
      case extd(pattern).contains("not", 0):
        pattern.shift();
        return [
          new NotPattern(getParamType(pattern[0]), pattern[1] || "m", parser.parseConstraint(pattern[2] || "true"), pattern[3] || {}, {
            scope: pattern.scope,
            pattern: pattern[2]
          })
        ];
      default:
        return [
          new ObjectPattern(getParamType(pattern[0]), pattern[1] || "m", parser.parseConstraint(pattern[2] || "true"), pattern[3] || {}, {
            scope: pattern.scope,
            pattern: pattern[2]
          })
        ];
    }
  };

  Rule = declare({
    instance: {
      constructor: function(name, options, pattern, cb) {
        this.name = name;
        this.pattern = pattern;
        this.cb = cb;
        if (options.agendaGroup) {
          this.agendaGroup = options.agendaGroup;
          this.autoFocus = (extd.isBoolean(options.autoFocus) ? options.autoFocus : false);
        }
        return this.priority = options.priority || options.salience || 0;
      },
      fire: function(flow, match) {
        var cb, e, ret;

        ret = new Promise();
        cb = this.cb;
        try {
          if (cb.length === 3) {
            cb.call(flow, match.factHash, flow, ret.classic);
          } else {
            cb.call(flow, match.factHash, flow);
          }
        } catch (_error) {
          e = _error;
          ret.errback(e);
        }
        return ret;
      }
    }
  });

  createRule = function(name, options, conditions, cb) {
    var condition, isRules, patterns, rules, scope, _i, _len, _mergePatterns;

    if (extd.isArray(options)) {
      cb = conditions;
      conditions = options;
    } else {
      options = options || {};
    }
    isRules = extd.every(conditions, function(cond) {
      return isArray(cond);
    });
    if (isRules && conditions.length === 1) {
      conditions = conditions[0];
      isRules = false;
    }
    rules = [];
    scope = options.scope || {};
    conditions.scope = scope;
    if (isRules) {
      patterns = [];
      _mergePatterns = function(patt, i) {
        if (!patterns[i]) {
          patterns[i] = (i === 0 ? [] : patterns[i - 1].slice());
          if (i !== 0) {
            patterns[i].pop();
          }
          return patterns[i].push(patt);
        } else {
          return extd(patterns).forEach(function(p) {
            return p.push(patt);
          });
        }
      };
      for (_i = 0, _len = conditions.length; _i < _len; _i++) {
        condition = conditions[_i];
        condition.scope = scope;
        extd.forEach(parsePattern(condition), _mergePatterns);
      }
      rules = extd.map(patterns, function(patts) {
        var compPat, i;

        compPat = null;
        i = 0;
        while (i < patts.length) {
          if (compPat === null) {
            compPat = new CompositePattern(patts[i++], patts[i]);
          } else {
            compPat = new CompositePattern(compPat, patts[i]);
          }
          i++;
        }
        return new Rule(name, options, compPat, cb);
      });
    } else {
      rules = extd.map(parsePattern(conditions), function(cond) {
        return new Rule(name, options, cond, cb);
      });
    }
    return rules;
  };

  exports.createRule = createRule;

}).call(this);
