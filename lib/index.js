// Generated by CoffeeScript 1.6.2
(function() {
  "use strict";
  var AgendaTree, Context, EventEmitter, Fact, FlowContainer, InitialFact, Promise, WorkingMemory, bind, compile, declare, extd, flows, forEach, fs, isNoolsFile, nools, parse, path, rule, wm;

  extd = require('./extended');

  fs = require('fs');

  path = require('path');

  bind = extd.bind;

  forEach = extd.forEach;

  declare = extd.declare;

  Promise = extd.Promise;

  EventEmitter = require('events').EventEmitter;

  rule = require('./rule');

  wm = require('./workingMemory');

  WorkingMemory = wm.WorkingMemory;

  InitialFact = require('./pattern').InitialFact;

  Fact = wm.Fact;

  compile = require('./compile');

  AgendaTree = require('./agenda');

  Context = require('./context');

  nools = {};

  flows = {};

  FlowContainer = declare({
    instance: {
      constructor: function(name, cb) {
        this.env = null;
        this.name = name;
        this.cb = cb;
        this.__rules = [];
        this.__defined = {};
        this.__wmAltered = false;
        this.workingMemory = new WorkingMemory();
        if (cb) {
          cb.call(this, this);
        }
        if (!flows.hasOwnProperty(name)) {
          return flows[name] = this;
        } else {
          throw new Error("Flow with " + name + " already defined");
        }
      },
      assert: function(fact) {
        this.__wmAltered = true;
        this.__factHelper(fact, true);
        return fact;
      },
      retract: function(fact) {
        this.__wmAltered = true;
        this.__factHelper(fact, false);
        return fact;
      },
      modify: function(fact, cb) {
        var f;

        f = this.retract(fact);
        if (typeof cb === "function") {
          cb.call(fact, fact);
        }
        return this.assert(f);
      },
      makeConstraintsList: function(ruleObj, patternNode) {
        if (patternNode.hasOwnProperty("leftPattern")) {
          this.makeConstraintsList(ruleObj, patternNode.leftPattern);
        }
        if (patternNode.hasOwnProperty("rightPattern")) {
          this.makeConstraintsList(ruleObj, patternNode.rightPattern);
        }
        if (patternNode.hasOwnProperty("constraints")) {
          return ruleObj.constraintsList.push(patternNode.constraints);
        }
      },
      match: function(cb) {
        var c, constraints, context, csFacts, dRule, fact, i, satisfyingFacts, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;

        _ref = this.__rules;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          dRule = _ref[_i];
          dRule.satisfyingFacts = [];
          dRule.constraintsList = [];
          this.makeConstraintsList(dRule, dRule.pattern);
        }
        _ref1 = this.__rules;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          dRule = _ref1[_j];
          _ref2 = dRule.constraintsList;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            constraints = _ref2[_k];
            csFacts = [];
            _ref3 = this.workingMemory.facts;
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              fact = _ref3[_l];
              if (this.satisfies(constraints, fact)) {
                csFacts.push(fact);
              }
            }
            dRule.satisfyingFacts.push(csFacts);
          }
        }
        this.__rules.sort(function(r1, r2) {
          return r1.priority - r2.priority;
        });
        _ref4 = this.__rules;
        _results = [];
        for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
          dRule = _ref4[_m];
          if (this.checkFire(dRule)) {
            context = new Context(dRule.satisfyingFacts[0][0]);
            context.set(dRule.constraintsList[0][0].alias, dRule.satisfyingFacts[0][0].object);
            _ref5 = dRule.satisfyingFacts;
            for (i = _n = 0, _len5 = _ref5.length; _n < _len5; i = ++_n) {
              satisfyingFacts = _ref5[i];
              if (i !== 0) {
                c = new Context(satisfyingFacts[0]);
                context.match = context.match.merge(c.match);
                context.set(dRule.constraintsList[i][0].alias, satisfyingFacts[0].object);
              }
            }
            _results.push(dRule.fire(this, context.match));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      },
      checkFire: function(r) {
        var satisfyingFacts, _i, _len, _ref;

        if (r.satisfyingFacts.length === 0) {
          return false;
        }
        _ref = r.satisfyingFacts;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          satisfyingFacts = _ref[_i];
          if (satisfyingFacts.length === 0) {
            return false;
          }
        }
        return true;
      },
      satisfies: function(constraints, fact) {
        var constraint, context, _i, _len;

        for (_i = 0, _len = constraints.length; _i < _len; _i++) {
          constraint = constraints[_i];
          switch (constraint.type) {
            case "object":
              if (!constraint.assert(fact.object)) {
                return false;
              }
              break;
            case "equality":
              context = new Context(fact);
              context.set(constraint.alias, context.fact.object);
              if (!constraint.assert(context.factHash)) {
                return false;
              }
          }
        }
        return true;
      },
      __factHelper: function(object, assert) {
        var f;

        f = new Fact(object);
        return f = (assert ? this.__assertFact(f) : this.__retractFact(f));
      },
      __assertFact: function(fact) {
        var wmFact;

        wmFact = this.workingMemory.assertFact(fact);
        return wmFact;
      },
      __retractFact: function(fact) {
        var wmFact;

        wmFact = this.workingMemory.retractFact(fact);
        return wmFact;
      },
      dispose: function() {
        return this.workingMemory.dispose();
      },
      getDefined: function(name) {
        var ret;

        ret = this.__defined[name.toLowerCase()];
        if (!ret) {
          throw new Error("" + name + " flow class is not defined");
        }
        return ret;
      },
      addDefined: function(name, cls) {
        this.__defined[name.toLowerCase()] = cls;
        return cls;
      },
      rule: function() {
        this.__rules = this.__rules.concat(rule.createRule.apply(rule, arguments));
        return this;
      },
      getSession: function() {
        var argument, _i, _len;

        this.assert(new InitialFact());
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          argument = arguments[_i];
          this.assert(argument);
        }
        return this;
      },
      containsRule: function(name) {
        return extd.some(this.__rules, function(rule) {
          return rule.name === name;
        });
      }
    }
  }).as(nools, "Flow");

  isNoolsFile = function(file) {
    return /.nools$/.test(file);
  };

  parse = function(source) {
    var ret;

    if (isNoolsFile(source)) {
      ret = compile.parse(fs.readFileSync(source, "utf-8"));
    } else {
      ret = compile.parse(source);
    }
    return ret;
  };

  nools.getFlow = function(name) {
    return flows[name];
  };

  nools.deleteFlow = function(name) {
    if (extd.instanceOf(name, FlowContainer)) {
      name = name.name;
    }
    delete flows[name];
    return nools;
  };

  nools.flow = function(name, cb) {
    return new FlowContainer(name, cb);
  };

  nools.compile = function(file, options, cb) {
    if (extd.isFunction(options)) {
      cb = options;
      options = {};
    } else {
      options || (options = {});
      cb = null;
    }
    if (extd.isString(file)) {
      options.name = options.name || (isNoolsFile(file) ? path.basename(file, path.extname(file)) : null);
      file = parse(file);
    }
    if (!options.name) {
      throw new Error("Name required when compiling nools source");
    }
    return compile.compile(file, options, cb, FlowContainer);
  };

  nools.parse = parse;

  module.exports = nools;

}).call(this);
