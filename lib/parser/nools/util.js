// Generated by CoffeeScript 1.6.2
/*

Defines utility functions for parsing

  function getTokensBetween(str, start, stop, includeStartEnd) --> list
    str             --> string to parse
    start           --> start token
    stop            --> stop token
    includeStartEnd --> whether to include start and stop tokens in the return list
  returns list  of characters between start and stop tokens

  function getParamList(str) --> string
    str   --> string to parse
  returns parameters of a function as a string

  function findNextTokenIndex(str, startIndex, endIndex) --> integer
    str         --> string to parse
    startIndex  --> index from where to start parsing
    endIndex    --> index where parsing should stop
  returns index of first non-whitespace character in the string str between [start index, end index)

  function findNextToken(str, startIndex, endIndex) --> character
    str   -->string to parse
    startIndex  --> index from where to start parsing
    endIndex    --> index where parsing should stop
  returns first non-whitespace character in the string str between [start index, end index)
*/


(function() {
  "use strict";
  var TOKEN_INVERTS, WHITE_SPACE_REG, findNextTokenIndex, getTokensBetween;

  WHITE_SPACE_REG = /[\s|\n|\r|\t]/;

  TOKEN_INVERTS = {
    '{': '}',
    '}': '{',
    '(': ')',
    ')': '(',
    '[': ']'
  };

  getTokensBetween = exports.getTokensBetween = function(str, start, stop, includeStartEnd, customError) {
    var cursor, depth, found, ret, startPushing, token;

    depth = 0;
    ret = [];
    if (!start) {
      start = TOKEN_INVERTS[stop];
      depth = 1;
    }
    stop || (stop = TOKEN_INVERTS[start]);
    str = Object(str);
    startPushing = false;
    cursor = 0;
    found = false;
    while (token = str.charAt(cursor++)) {
      if (token === start) {
        depth++;
        if (!startPushing) {
          startPushing = true;
          if (includeStartEnd) {
            ret.push(token);
          }
        } else {
          ret.push(token);
        }
      } else if ((token === stop) && cursor) {
        depth--;
        if (depth === 0) {
          if (includeStartEnd) {
            ret.push(token);
          }
          found = true;
          break;
        }
        ret.push(token);
      } else if (startPushing) {
        ret.push(token);
      }
    }
    if (!found) {
      throw new Error(customError ? customError : "Unable to match " + start + " in " + str);
    }
    return ret;
  };

  exports.getParamList = function(str, customError) {
    return getTokensBetween(str, "(", ")", true, customError).join("");
  };

  findNextTokenIndex = exports.findNextTokenIndex = function(str, startIndex, endIndex) {
    var l, ret;

    startIndex || (startIndex = 0);
    l = str.length;
    endIndex || (endIndex = l);
    ret = -1;
    if ((!endIndex) || (endIndex > l)) {
      endIndex = l;
    }
    while (startIndex < endIndex) {
      if (!WHITE_SPACE_REG.test(str.charAt(startIndex))) {
        ret = startIndex;
        break;
      }
      startIndex++;
    }
    return ret;
  };

  exports.findNextToken = function(str, startIndex, endIndex) {
    return str.charAt(findNextTokenIndex(str, startIndex, endIndex));
  };

}).call(this);
