// Generated by CoffeeScript 1.6.2
/*

  Defines functions for parsing actions and for creating rules, functions and defined objects

  parseAction(action, identifiers, defined, scope) --> Function
    action --> string containing the action code
    identifiers --> a list of identifiers for declaring variables used in action
    defined --> ??
    scope --> ??
  returns a function which when executed, executes the code in the action string
  
  __resolveRule(rule, identifiers, conditions, defined, name) --> Nothing
    rule --> List representing a rule constraint
    identifiers --> a list to populate with identifiers defined in rule constraint
    conditions --> a nested list to populate with rule constraints
    defined --> ???
    name --> ???
  return Nothing

  createRuleFromObject(obj, defined, scope) --> Rule Object
    obj --> An object of ??? type containing rule name, scope, constraints and action
    defined --> ???
    scope --> ???
  returns a Rule object representing obj parameter

  createFunction(body, defined, scope, scopeNames, definedNames) --> Function
    body --> string containing code of function
    defined --> ???
    scope --> ???
    scopeNames --> ???
    definedNames --> ???
  returns a function which executes the code written in the string

  _createDefined(options) --> Hash type object for class
    options --> a string or hash object containing definitions in define block
  returns a hash type object which describes a class, containing a constructor and properties mentioned in hash object

  createDefined(options) --> calls _createDefined with options.properties
    options --> a hash representing defined object
  
  parse(src) --> 
    src --> string containing DSL code

  compile(flowObj, options, cb, Container) --> Container object
    flowObj --> ???
    options --> ???
    cb --> ??? most probably a callback function
    Container --> ???
    returns an instance of Container object
*/


(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  (function() {
    "use strict";
    var bind, constraintMatcher, createDefined, createFunction, createRuleFromObject, extd, forEach, indexOf, isString, keys, map, merge, modifiers, parseAction, parser, removeDuplicates, rules;

    extd = require('./extended.coffee');
    parser = require('./parser');
    constraintMatcher = require('./constraintMatcher.coffee');
    indexOf = extd.indexOf;
    forEach = extd.forEach;
    map = extd.map;
    removeDuplicates = extd.removeDuplicates;
    keys = extd.hash.keys;
    merge = extd.merge;
    isString = extd.isString;
    bind = extd.bind;
    rules = require('./rule.coffee');
    modifiers = ["assert", "modify", "retract", "emit", "halt", "focus"];
    parseAction = function(action, identifiers, defined, scope) {
      var declares, e, i, j, params, _i, _j, _len, _len1;

      declares = [];
      for (_i = 0, _len = identifiers.length; _i < _len; _i++) {
        i = identifiers[_i];
        if (action.indexOf(i) !== -1) {
          declares.push("var " + i + " = facts." + i + ";");
        }
      }
      for (_j = 0, _len1 = modifiers.length; _j < _len1; _j++) {
        i = modifiers[_j];
        if (action.indexOf(i) !== -1) {
          declares.push("var " + i + " = bind(flow, flow." + i + ");");
        }
      }
      for (i in defined) {
        j = defined[i];
        if (action.indexOf(i) !== -1) {
          declares.push("var " + i + " = defined." + i + ";");
        }
      }
      for (i in scope) {
        j = scope[i];
        if (action.indexOf(i) !== -1) {
          declares.push("var " + i + " = scope." + i + ";");
        }
      }
      params = ["facts", "flow"];
      if (/next\(.*\)/.test(action)) {
        params.push("next");
      }
      action = "with(this){" + declares.join("") + ("" + action + "}");
      try {
        return bind({
          defined: defined,
          scope: scope,
          bind: bind
        }, new Function(params.join(","), action));
      } catch (_error) {
        e = _error;
        throw new Error("Invalid action : " + action + "\n" + e.message);
      }
    };
    createRuleFromObject = (function() {
      var __resolveRule;

      __resolveRule = function(rule, identifiers, conditions, defined, name) {
        var alias, condition, constraint, definedClass, i, ident, j, refs, _i, _len, _ref, _results;

        condition = [];
        definedClass = rule[0];
        alias = rule[1];
        constraint = rule[2];
        refs = rule[3];
        if (extd.isHash(constraint)) {
          refs = constraint;
          constraint = null;
        }
        if (definedClass && !!(definedClass = defined[definedClass])) {
          condition.push(definedClass);
        } else {
          throw new Error("Invalid class " + rule[0] + " for rule " + name);
        }
        condition.push(alias, constraint, refs);
        conditions.push(condition);
        identifiers.push(alias);
        if (constraint) {
          _ref = constraintMatcher.getIdentifiers(parser.parseConstraint(constraint));
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            i = _ref[_i];
            identifiers.push(i);
          }
        }
        if (extd.isObject(refs)) {
          _results = [];
          for (j in refs) {
            ident = refs[j];
            if (__indexOf.call(identifiers, ident) < 0) {
              _results.push(identifiers.push(ident));
            }
          }
          return _results;
        }
      };
      return function(obj, defined, scope) {
        var action, cond, conditions, conds, constraints, identifiers, name, options, r0, rule, temp, _i, _j, _len, _len1;

        name = obj.name;
        if (extd.isEmpty(obj)) {
          throw new Error("Rule is empty");
        }
        options = obj.options || {};
        options.scope = scope;
        constraints = obj.constraints || [];
        if (!constraints.length) {
          constraints = ["true"];
        }
        action = obj.action;
        if (extd.isUndefined(action)) {
          throw new Error("No action was defined for rule " + name);
        }
        conditions = [];
        identifiers = [];
        for (_i = 0, _len = constraints.length; _i < _len; _i++) {
          rule = constraints[_i];
          if (rule.length) {
            r0 = rule[0];
            if (r0 === "not") {
              temp = [];
              rule.shift();
              __resolveRule(rule, identifiers, temp, defined, name);
              cond = temp[0];
              cond.unshift(r0);
              conditions.push(cond);
            } else if (r0 === "or") {
              conds = [r0];
              rule.shift();
              for (_j = 0, _len1 = rule.length; _j < _len1; _j++) {
                cond = rule[_j];
                __resolveRule(cond, identifiers, conds, defined, name);
              }
              conditions.push(conds);
            } else {
              __resolveRule(rule, identifiers, conditions, defined, name);
              identifiers = removeDuplicates(identifiers);
            }
          }
        }
        return rules.createRule(name, options, conditions, parseAction(action, identifiers, defined, scope));
      };
    })();
    createFunction = function(body, defined, scope, scopeNames, definedNames) {
      var declares, e, i, _i, _j, _len, _len1;

      declares = [];
      for (_i = 0, _len = definedNames.length; _i < _len; _i++) {
        i = definedNames[_i];
        if (body.indexOf(i) !== -1) {
          declares.push("var " + i + " = defined." + i + ";");
        }
      }
      for (_j = 0, _len1 = scopeNames.length; _j < _len1; _j++) {
        i = scopeNames[_j];
        if (body.indexOf(i) !== -1) {
          declares.push("var " + i + " = scope." + i + ";");
        }
      }
      body = ["((function(){", declares.join(""), "\n\treturn ", body, "\n})())"].join("");
      try {
        return eval(body);
      } catch (_error) {
        e = _error;
        throw new Error("Invalid action : " + body + "\n" + e.message);
      }
    };
    createDefined = (function() {
      var _createDefined;

      _createDefined = function(options) {
        var i, ret;

        options = (isString(options) ? (new Function("return " + options + ";"))() : options);
        ret = 0;
        if (options.hasOwnProperty("constructor") && typeof options.constructor === "function") {
          ret = options.constructor;
        } else {
          ret = function(opts) {
            var i;

            opts || (opts = {});
            for (i in opts) {
              if (i in options) {
                this[i] = opts[i];
              }
            }
            return this;
          };
        }
        for (i in options) {
          ret.prototype[i] = options[i];
        }
        return ret;
      };
      return function(options) {
        return _createDefined(options.properties);
      };
    })();
    exports.parse = function(src) {
      return parser.parseRuleSet(src);
    };
    return exports.compile = function(flowObj, options, cb, Container) {
      var cls, defined, definedNames, fRules, flow, name, rule, scope, scopeNames, _i, _len;

      if (extd.isFunction(options)) {
        cb = options;
        options = {};
      } else {
        options || (options = {});
        cb = null;
      }
      name = flowObj.name || options.name;
      if (!name) {
        throw new Error("Name must be present in JSON or options");
      }
      flow = new Container(name);
      defined = merge({
        Array: Array,
        String: String,
        Number: Number,
        Boolean: Boolean,
        RegExp: RegExp,
        Date: Date,
        Object: Object
      }, options.define || {});
      if (typeof Buffer !== "undefined") {
        defined.Buffer = Buffer;
      }
      scope = merge({
        console: console
      }, options.scope);
      forEach(flowObj.define, function(d) {
        return defined[d.name] = createDefined(d);
      });
      for (name in defined) {
        cls = defined[name];
        flow.addDefined(name, cls);
      }
      scopeNames = extd(flowObj.scope).pluck("name").union(extd(scope).keys()).value();
      definedNames = map(keys(defined), function(s) {
        return s;
      });
      forEach(flowObj.scope, function(s) {
        return scope[s.name] = createFunction(s.body, defined, scope, scopeNames, definedNames);
      });
      fRules = flowObj.rules;
      if (fRules.length) {
        for (_i = 0, _len = fRules.length; _i < _len; _i++) {
          rule = fRules[_i];
          flow.__rules = flow.__rules.concat(createRuleFromObject(rule, defined, scope));
        }
      }
      if (cb) {
        cb.call(flow, flow);
      }
      return flow;
    };
  })();

}).call(this);
